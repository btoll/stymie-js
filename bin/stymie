#!/usr/bin/env node

const inquirer = require('inquirer');
const init = require('../src/init');
const jcrypt = require('jcrypt');
const key = require('../src/');
const logger = require('logger');
const prompts = require('../src/prompts');
const util = require('../src/util');

const argv = require('yargs')
    .usage('Usage: stymie <command> [options]')
    .example('stymie init', 'Installs')
    .command('init', 'Install the password file directory and config file')

    .example('stymie generate', 'Generates a diceware passphrase')
    .command('generate', 'Generate a passphrase')

    .command('', '')

    .example('stymie add', 'Adds a new entry')
    .command('add', 'Add a new entry')

    .example('stymie edit', 'Edits an entry')
    .command('edit', 'Edit an entry')

    .example('stymie get', 'Retrieves an entry')
    .command('get', 'Get an entry')

    .example('stymie has', 'Checks if the entry exists')
    .command('has', 'Check if the entry exists')

    .example('stymie list', 'Lists all entries')
    .command('list', 'List all entries')
    .command('ls', 'Alias of `list`')

    .example('stymie rm', 'Deletes an entry')
    .command('rm', 'Delete an entry')

    .alias('f', 'field')
    .describe('field', 'Gets the specified key value from an entry (only with `get` command)')

    .alias('s', 'strip')
    .describe('strip', 'Strips any whitespace from a field (only with `get` command)')

    .help('h')
    .alias('h', 'help')
    .argv;

const command = argv._[0];
const env = process.env;
const stymieDir = `${env.STYMIE || env.HOME}/.stymie.d`;

const logError = logger.error;
const logInfo = logger.info;
const logRaw = logger.raw;
const logSuccess = logger.success;

if (command === 'init') {
    // TODO: Allow multiple installations in multiple locations?
    util.fileExists(`${stymieDir}/c`)
    .then(() => util.logWarn('Stymie already exists!'))
    .catch(init);
} else {
    util.fileExists(`${stymieDir}/c`)
    .then(configFile =>
        jcrypt.decryptFile(configFile)
        .then(gpgOptions => {
            util.setGPGOptions(JSON.parse(gpgOptions));

            switch (command) {
                case 'add':
                    key.add(argv._[1])
                    .then(data => {
                        if (typeof data !== 'string') {
                            logInfo('Nothing to do here');
                        } else {
                            logSuccess('Key has been added');
                        }
                    })
                    .catch(logError);
                    break;

                case 'edit': key.edit(argv._[1]); break;

                case 'generate':
                    logger.raw(key.generate());
                    break;

                case 'get':
                    key.get(argv._[1], argv.field)
                    .then(res => {
                        if (typeof res === 'boolean') {
                            // Either no key or no field value within a known key.
                            logInfo('Nothing to do here');
                        } else if (typeof res === 'object') {
                            // Dump the whole object.
                            logInfo(`Results for key \`${res.key}\``);

                            const entry = res.entry;

                            for (let n of Object.keys(entry)) {
                                logRaw(`${n}: ${entry[n]}`);
                            }
                        } else {
                            // `res` will be a field value.
                            // Don't log here b/c we don't want the newline char! This is best when
                            // copying to clipboard, i.e.:
                            //
                            //      stymie get example.com -f password -s | pbcopy
                            //
                            // To view the logged output, get the whole entry (don't specify a `field`).
                            process.stdout.write(res);
                        }
                    });
                    break;

                case 'has':
                    key.has(argv._[1])
                    .then(res =>
                        logInfo(
                            res ?
                                'Key exists' :
                                'No matching key'
                        )
                    )
                    .catch(logError);
                    break;

                case 'list':
                case 'ls':
                    key.list()
                    .then(keys =>
                        logInfo(
                            !keys.length ?
                                'No installed keys' :
                                `Installed keys: \n${keys.join('\n')}`
                        )
                    )
                    .catch(logError);
                    break;

                case 'rm':
                    key.rm(argv._[1])
                    .then(data => {
                        if (typeof data === 'string') {
                            logInfo('Nothing to do here');
                        } else {
                            logSuccess('Key has been removed');
                        }
                    })
                    .catch(() => logError('No removal'));
                    break;

                default: util.logError('Bad command');
            }
        })
        .catch(util.logError)
    )
    .catch(err => {
        // TODO: Canceling GPG when asking for passphrase will get here, THIS IS NOT GOOD!
        util.logWarn('It appears that stymie is not installed.\n');

        inquirer.prompt(prompts.bin, answers => {
            if (!answers.install) {
                util.logInfo('Aborting install.');
            } else {
                init();
            }
        });
    });
}

